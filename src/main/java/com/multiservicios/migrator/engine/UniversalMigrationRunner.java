package com.multiservicios.migrator.engine;

import java.util.List;
import java.util.Map;
import java.util.HashSet;
import java.util.ArrayList;
import java.util.Set;

import javax.sql.DataSource;

import org.springframework.stereotype.Component;

import com.multiservicios.migrator.extract.SqlExtractor;
import com.multiservicios.migrator.load.UniversalTableLoader;
import com.multiservicios.migrator.logs.MigrationLogService;
import com.multiservicios.migrator.model.FieldMapping;
import com.multiservicios.migrator.model.RowData;
import com.multiservicios.migrator.transform.UniversalMappingEngine;

@Component
public class UniversalMigrationRunner {
	private final SqlExtractor extractor;
	private final UniversalMappingEngine mappingEngine;
	private final UniversalTableLoader loader;
	private final MigrationLogService logService;

	public UniversalMigrationRunner(SqlExtractor extractor, UniversalMappingEngine mappingEngine, UniversalTableLoader loader,
			MigrationLogService logService) {
		this.extractor = extractor;
		this.mappingEngine = mappingEngine;
		this.loader = loader;
		this.logService = logService;
	}

	public UniversalRunResult run(DataSource origen, DataSource destino, String sql, List<FieldMapping> mappings,
			String schema, String table, boolean dryRun) {
		logService.clear();
		List<RowData> rows = extractor.extract(origen, sql);

		String duplicatesError = validateDuplicateTargets(mappings);
		if (duplicatesError != null) {
			logService.error(0, duplicatesError);
			return new UniversalRunResult(rows.size(), 0, rows.size(), dryRun);
		}

		Set<String> allowed;
		Map<String, com.multiservicios.migrator.model.ColumnMeta> metaByLower = null;
		try {
			allowed = loader.loadAllowedColumnsLower(destino, schema, table);
			metaByLower = loader.loadColumnMetaByLower(destino, schema, table);
		} catch (Exception ex) {
			logService.error(0, "No se pudo leer columnas del destino: " + ex.getMessage());
			return new UniversalRunResult(rows.size(), 0, rows.size(), dryRun);
		}

		String precheckError = validateRequiredColumns(metaByLower, mappings);
		if (precheckError != null) {
			logService.error(0, precheckError);
			return new UniversalRunResult(rows.size(), 0, rows.size(), dryRun);
		}

		List<String> autoGenTargets = findAutogeneratedTargets(metaByLower, mappings);
		if (!autoGenTargets.isEmpty()) {
			logService.info(0,
					"Se ignorarán mapeos a columnas autogeneradas (AUTO_INCREMENT/GENERATED): " + String.join(", ", autoGenTargets));
		}

		int ok = 0;
		int fail = 0;
		for (int i = 0; i < rows.size(); i++) {
			int rowNumber = i + 1;
			try {
				var values = mappingEngine.mapToColumns(rows.get(i), mappings);
				var result = loader.insertRow(destino, schema, table, values, allowed, metaByLower, dryRun);
				if (result.success()) {
					ok++;
					logService.info(rowNumber, result.message());
				} else {
					fail++;
					logService.error(rowNumber, result.message());
				}
			} catch (Exception ex) {
				fail++;
				logService.error(rowNumber, ex.getClass().getSimpleName() + ": " + ex.getMessage());
			}
		}

		return new UniversalRunResult(rows.size(), ok, fail, dryRun);
	}

	public ValidationResult validateSample(DataSource origen, DataSource destino, String limitedSql,
			List<FieldMapping> mappings, String schema, String table) {
		List<String> errors = new ArrayList<>();
		List<String> warnings = new ArrayList<>();

		List<RowData> rows = extractor.extract(origen, limitedSql);

		String duplicatesError = validateDuplicateTargets(mappings);
		if (duplicatesError != null) {
			errors.add(duplicatesError);
			return new ValidationResult(false, rows.size(), errors, warnings);
		}

		Set<String> allowed;
		Map<String, com.multiservicios.migrator.model.ColumnMeta> metaByLower;
		try {
			allowed = loader.loadAllowedColumnsLower(destino, schema, table);
			metaByLower = loader.loadColumnMetaByLower(destino, schema, table);
		} catch (Exception ex) {
			errors.add("No se pudo leer metadata del destino: " + ex.getMessage());
			return new ValidationResult(false, rows.size(), errors, warnings);
		}

		String precheck = validateRequiredColumns(metaByLower, mappings);
		if (precheck != null) {
			errors.add(precheck);
			return new ValidationResult(false, rows.size(), errors, warnings);
		}

		List<String> autoGenTargets = findAutogeneratedTargets(metaByLower, mappings);
		if (!autoGenTargets.isEmpty()) {
			warnings.add(
					"Se ignorarán mapeos a columnas autogeneradas (AUTO_INCREMENT/GENERATED) y el destino asignará el valor: "
							+ String.join(", ", autoGenTargets));
		}

		for (int i = 0; i < rows.size(); i++) {
			int rowNumber = i + 1;
			try {
				var values = mappingEngine.mapToColumns(rows.get(i), mappings);
				// validar NOT NULL por fila (cuando el mapping existe pero el dato viene null)
				for (var e : metaByLower.entrySet()) {
					var meta = e.getValue();
					if (meta == null || !meta.isRequiredInput()) {
						continue;
					}
					if (!values.containsKey(meta.name())) {
						// puede venir con distinto case
						Object v2 = values.get(meta.nameLower());
						if (v2 == null) {
							errors.add("row=" + rowNumber + " falta valor requerido en columna destino '" + meta.name() + "'");
						}
						continue;
					}
					Object v = values.get(meta.name());
					if (v == null || (v instanceof String s && s.trim().isEmpty())) {
						errors.add("row=" + rowNumber + " valor NULL/vacío para columna NOT NULL '" + meta.name() + "'");
					}
				}

				var result = loader.insertRow(destino, schema, table, values, allowed, metaByLower, true);
				if (!result.success()) {
					errors.add("row=" + rowNumber + " " + result.message());
				}
			} catch (Exception ex) {
				errors.add("row=" + rowNumber + " " + ex.getClass().getSimpleName() + ": " + ex.getMessage());
			}

			if (errors.size() >= 25) {
				warnings.add("Se truncó la lista de errores a 25 (hay más filas con problemas)");
				break;
			}
		}

		return new ValidationResult(errors.isEmpty(), rows.size(), errors, warnings);
	}

	public record ValidationResult(boolean ok, int sampledRows, List<String> errors, List<String> warnings) {
	}

	private static String validateDuplicateTargets(List<FieldMapping> mappings) {
		if (mappings == null || mappings.isEmpty()) {
			return null;
		}
		Map<String, Integer> counts = new java.util.LinkedHashMap<>();
		for (FieldMapping m : mappings) {
			if (m == null || m.getTarget() == null) {
				continue;
			}
			String t = m.getTarget().trim();
			if (t.isEmpty()) {
				continue;
			}
			String key = t.toLowerCase();
			counts.put(key, counts.getOrDefault(key, 0) + 1);
		}

		StringBuilder dupes = new StringBuilder();
		for (var e : counts.entrySet()) {
			if (e.getValue() != null && e.getValue() > 1) {
				if (dupes.length() > 0) {
					dupes.append(", ");
				}
				dupes.append(e.getKey());
				dupes.append(" (");
				dupes.append(e.getValue());
				dupes.append(")");
			}
		}
		if (dupes.length() == 0) {
			return null;
		}
		return "Hay mapeos duplicados hacia el mismo campo destino: " + dupes
				+ ". Un campo destino solo puede venir de UNA fuente; usá una EXPRESION tipo coalesce.";
	}

	private static List<String> findAutogeneratedTargets(
			Map<String, com.multiservicios.migrator.model.ColumnMeta> metaByLower,
			List<FieldMapping> mappings) {
		if (metaByLower == null || metaByLower.isEmpty() || mappings == null || mappings.isEmpty()) {
			return List.of();
		}
		List<String> list = new ArrayList<>();
		Set<String> seen = new HashSet<>();
		for (FieldMapping m : mappings) {
			if (m == null || m.getTarget() == null || m.getTarget().isBlank()) {
				continue;
			}
			String targetLower = m.getTarget().trim().toLowerCase();
			var meta = metaByLower.get(targetLower);
			if (meta == null) {
				continue;
			}
			if (meta.autoIncrement() || meta.generated()) {
				String name = meta.name();
				String key = name == null ? targetLower : name.toLowerCase();
				if (seen.add(key)) {
					list.add(name == null || name.isBlank() ? m.getTarget().trim() : name);
				}
			}
		}
		return list;
	}

	private static String validateRequiredColumns(Map<String, com.multiservicios.migrator.model.ColumnMeta> metaByLower,
			List<FieldMapping> mappings) {
		if (metaByLower == null || metaByLower.isEmpty()) {
			return null;
		}
		Set<String> targetsLower = new HashSet<>();
		if (mappings != null) {
			for (FieldMapping m : mappings) {
				if (m == null || m.getTarget() == null || m.getTarget().isBlank()) {
					continue;
				}
				targetsLower.add(m.getTarget().trim().toLowerCase());
			}
		}

		StringBuilder missing = new StringBuilder();
		for (var e : metaByLower.entrySet()) {
			var meta = e.getValue();
			if (meta == null) {
				continue;
			}
			if (!meta.isRequiredInput()) {
				continue;
			}
			if (!targetsLower.contains(meta.nameLower())) {
				if (missing.length() > 0) {
					missing.append(", ");
				}
				missing.append(meta.name());
			}
		}
		if (missing.length() == 0) {
			return null;
		}
		return "Faltan mapeos para columnas NOT NULL sin default en destino: " + missing;
	}

	public record UniversalRunResult(int total, int ok, int fail, boolean dryRun) {
	}
}
